{"ast":null,"code":"import _objectWithoutProperties from \"/home/nik/projects/three-fiber-excercises/42-first-r3f-application/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"/home/nik/projects/three-fiber-excercises/42-first-r3f-application/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/home/nik/projects/three-fiber-excercises/42-first-r3f-application/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/home/nik/projects/three-fiber-excercises/42-first-r3f-application/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { c as createEvents, e as extend, u as useMutableCallback, a as createRoot, i as isRef, E as ErrorBoundary, B as Block, b as useIsomorphicLayoutEffect, d as unmountComponentAtNode } from './index-b9d9a4a8.esm.js';\nexport { t as ReactThreeFiber, v as _roots, s as act, o as addAfterEffect, n as addEffect, p as addTail, m as advance, j as applyProps, f as context, c as createEvents, g as createPortal, a as createRoot, k as dispose, e as extend, q as getRootState, l as invalidate, h as reconciler, r as render, d as unmountComponentAtNode, z as useFrame, A as useGraph, w as useInstanceHandle, C as useLoader, x as useStore, y as useThree } from './index-b9d9a4a8.esm.js';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport useMeasure from 'react-use-measure';\nimport { FiberProvider, useContextBridge } from 'its-fine';\nimport 'react-reconciler/constants';\nimport 'zustand';\nimport 'react-reconciler';\nimport 'scheduler';\nimport 'suspend-react';\nvar DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n/** Default R3F event manager for web */\n\nfunction createPointerEvents(store) {\n  var _createEvents = createEvents(store),\n    handlePointer = _createEvents.handlePointer;\n  return {\n    priority: 1,\n    enabled: true,\n    compute: function compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, handlePointer(key)));\n    }, {}),\n    connect: function connect(target) {\n      var _events$handlers;\n      var _store$getState = store.getState(),\n        set = _store$getState.set,\n        events = _store$getState.events;\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(function (state) {\n        return {\n          events: _objectSpread({}, state.events, {\n            connected: target\n          })\n        };\n      });\n      Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          name = _ref2[0],\n          event = _ref2[1];\n        var _DOM_EVENTS$name = _slicedToArray(DOM_EVENTS[name], 2),\n          eventName = _DOM_EVENTS$name[0],\n          passive = _DOM_EVENTS$name[1];\n        target.addEventListener(eventName, event, {\n          passive: passive\n        });\n      });\n    },\n    disconnect: function disconnect() {\n      var _store$getState2 = store.getState(),\n        set = _store$getState2.set,\n        events = _store$getState2.events;\n      if (events.connected) {\n        var _events$handlers2;\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            event = _ref4[1];\n          if (events && events.connected instanceof HTMLElement) {\n            var _DOM_EVENTS$name2 = _slicedToArray(DOM_EVENTS[name], 1),\n              eventName = _DOM_EVENTS$name2[0];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(function (state) {\n          return {\n            events: _objectSpread({}, state.events, {\n              connected: undefined\n            })\n          };\n        });\n      }\n    }\n  };\n}\nvar CanvasImpl = /*#__PURE__*/React.forwardRef(function Canvas(_ref5, forwardedRef) {\n  var children = _ref5.children,\n    fallback = _ref5.fallback,\n    resize = _ref5.resize,\n    style = _ref5.style,\n    gl = _ref5.gl,\n    _ref5$events = _ref5.events,\n    events = _ref5$events === void 0 ? createPointerEvents : _ref5$events,\n    eventSource = _ref5.eventSource,\n    eventPrefix = _ref5.eventPrefix,\n    shadows = _ref5.shadows,\n    linear = _ref5.linear,\n    flat = _ref5.flat,\n    legacy = _ref5.legacy,\n    orthographic = _ref5.orthographic,\n    frameloop = _ref5.frameloop,\n    dpr = _ref5.dpr,\n    performance = _ref5.performance,\n    raycaster = _ref5.raycaster,\n    camera = _ref5.camera,\n    onPointerMissed = _ref5.onPointerMissed,\n    _onCreated = _ref5.onCreated,\n    props = _objectWithoutProperties(_ref5, [\"children\", \"fallback\", \"resize\", \"style\", \"gl\", \"events\", \"eventSource\", \"eventPrefix\", \"shadows\", \"linear\", \"flat\", \"legacy\", \"orthographic\", \"frameloop\", \"dpr\", \"performance\", \"raycaster\", \"camera\", \"onPointerMissed\", \"onCreated\"]);\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  React.useMemo(function () {\n    return extend(THREE);\n  }, []);\n  var Bridge = useContextBridge();\n  var _useMeasure = useMeasure(_objectSpread({\n      scroll: true,\n      debounce: {\n        scroll: 50,\n        resize: 0\n      }\n    }, resize)),\n    _useMeasure2 = _slicedToArray(_useMeasure, 2),\n    containerRef = _useMeasure2[0],\n    containerRect = _useMeasure2[1];\n  var canvasRef = React.useRef(null);\n  var divRef = React.useRef(null);\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    canvas = _React$useState2[0],\n    setCanvas = _React$useState2[1];\n  React.useImperativeHandle(forwardedRef, function () {\n    return canvasRef.current;\n  });\n  var handlePointerMissed = useMutableCallback(onPointerMissed);\n  var _React$useState3 = React.useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    block = _React$useState4[0],\n    setBlock = _React$useState4[1];\n  var _React$useState5 = React.useState(false),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    error = _React$useState6[0],\n    setError = _React$useState6[1]; // Suspend this component if block is a promise (2nd run)\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error;\n  var root = React.useRef(null);\n  if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n    if (!root.current) root.current = createRoot(canvas);\n    root.current.configure({\n      gl: gl,\n      events: events,\n      shadows: shadows,\n      linear: linear,\n      flat: flat,\n      legacy: legacy,\n      orthographic: orthographic,\n      frameloop: frameloop,\n      dpr: dpr,\n      performance: performance,\n      raycaster: raycaster,\n      camera: camera,\n      size: containerRect,\n      // Pass mutable reference to onPointerMissed so it's free to update\n      onPointerMissed: function onPointerMissed() {\n        return handlePointerMissed.current == null ? void 0 : handlePointerMissed.current.apply(handlePointerMissed, arguments);\n      },\n      onCreated: function onCreated(state) {\n        // Connect to event source\n        state.events.connect == null ? void 0 : state.events.connect(eventSource ? isRef(eventSource) ? eventSource.current : eventSource : divRef.current); // Set up compute function\n\n        if (eventPrefix) {\n          state.setEvents({\n            compute: function compute(event, state) {\n              var x = event[eventPrefix + 'X'];\n              var y = event[eventPrefix + 'Y'];\n              state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n              state.raycaster.setFromCamera(state.pointer, state.camera);\n            }\n          });\n        } // Call onCreated callback\n\n        _onCreated == null ? void 0 : _onCreated(state);\n      }\n    });\n    root.current.render( /*#__PURE__*/React.createElement(Bridge, null, /*#__PURE__*/React.createElement(ErrorBoundary, {\n      set: setError\n    }, /*#__PURE__*/React.createElement(React.Suspense, {\n      fallback: /*#__PURE__*/React.createElement(Block, {\n        set: setBlock\n      })\n    }, children))));\n  }\n  useIsomorphicLayoutEffect(function () {\n    setCanvas(canvasRef.current);\n  }, []);\n  React.useEffect(function () {\n    if (canvas) return function () {\n      return unmountComponentAtNode(canvas);\n    };\n  }, [canvas]); // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n\n  var pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: divRef,\n    style: _objectSpread({\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents: pointerEvents\n    }, style)\n  }, props), /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    style: {\n      width: '100%',\n      height: '100%'\n    }\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      display: 'block'\n    }\n  }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */\n\nvar Canvas = /*#__PURE__*/React.forwardRef(function CanvasWrapper(props, ref) {\n  return /*#__PURE__*/React.createElement(FiberProvider, null, /*#__PURE__*/React.createElement(CanvasImpl, _extends({}, props, {\n    ref: ref\n  })));\n});\nexport { Canvas, createPointerEvents as events };","map":null,"metadata":{},"sourceType":"module"}